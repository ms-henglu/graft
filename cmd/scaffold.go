package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/hashicorp/hcl/v2/hclsyntax"
	"github.com/hashicorp/hcl/v2/hclwrite"
	"github.com/ms-henglu/graft/internal/log"
	"github.com/ms-henglu/graft/internal/scaffold"
	"github.com/ms-henglu/graft/internal/tree"
	"github.com/ms-henglu/graft/internal/vendors"
	"github.com/spf13/cobra"
)

var outputFile string

func NewScaffoldCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "scaffold [MODULE_KEY]",
		Short: "Scaffold a graft manifest for a module",
		RunE: func(cmd *cobra.Command, args []string) error {
			log.Section("Discovering modules in .terraform/modules...")

			cwd, err := os.Getwd()
			if err != nil {
				return err
			}
			modulesJSON, err := vendors.LoadModulesJSON(cwd)
			if err != nil {
				return err
			}

			// sort the modulesJSON.Modules by the number of parts in Key to ensure parents are created before children
			sort.SliceStable(modulesJSON.Modules, func(i, j int) bool {
				return len(strings.Split(modulesJSON.Modules[i].Key, ".")) < len(strings.Split(modulesJSON.Modules[j].Key, "."))
			})

			// scan modules and build tree
			moduleNodes := make(map[string]*scaffold.ModuleNode)
			rootNode := &scaffold.ModuleNode{
				Key:      "root",
				Children: []*scaffold.ModuleNode{},
			}
			moduleNodes["root"] = rootNode
			for _, mod := range modulesJSON.Modules {
				// Skip root module
				if mod.Key == "" {
					continue
				}

				dir := mod.Dir
				if !filepath.IsAbs(dir) {
					dir = filepath.Join(cwd, dir)
				}

				// Count resources
				resources, err := scaffold.ScanResources(dir)
				if err != nil {
					log.Warn(fmt.Sprintf("Failed to scan resources for %s: %v", mod.Key, err))
				}

				node := &scaffold.ModuleNode{
					Key:              mod.Key,
					Module:           mod,
					Resources:        resources,
					Children:         []*scaffold.ModuleNode{},
					IsScaffoldTarget: true,
				}
				moduleNodes[mod.Key] = node

				parentKey := "root"
				if dotIndex := strings.LastIndex(mod.Key, "."); dotIndex != -1 {
					parentKey = mod.Key[:dotIndex]
				}

				if parent, ok := moduleNodes[parentKey]; ok {
					parent.Children = append(parent.Children, node)
				} else {
					log.Warn(fmt.Sprintf("Skipping module %s: parent module %s not found", mod.Key, parentKey))
				}
			}

			// Print module tree
			tree.Print(scaffold.ToTreeNode(rootNode))

			if len(args) == 0 {
				log.Hint("Tip: Run 'graft scaffold <MODULE_KEY>' to generate a manifest for a specific module.")
				log.Hint("Example: graft scaffold linux_servers.os")
			} else {
				log.Section(fmt.Sprintf("Scaffolding module: %s", strings.Join(args, " ")))
			}

			// Generate scaffold.graft.hcl
			filename := outputFile
			if filename == "" {
				filename = "scaffold.graft.hcl"
			}
			savePath := filename
			if !filepath.IsAbs(savePath) {
				savePath = filepath.Join(cwd, savePath)
			}

			f := hclwrite.NewEmptyFile()
			rootBody := f.Body()
			rootBody.AppendUnstructuredTokens(hclwrite.Tokens{
				{Type: hclsyntax.TokenComment, Bytes: []byte("# Generated by graft scaffold\n")},
			})
			rootBody.AppendNewline()
			dummyBlock := hclwrite.NewBlock("dummy", nil)
			scaffold.WriteModuleBlock(dummyBlock, rootNode, args)
			for _, b := range dummyBlock.Body().Blocks() {
				if b.Type() == "module" && len(b.Labels()) == 1 && b.Labels()[0] == "root" {
					for _, childBlock := range b.Body().Blocks() {
						rootBody.AppendBlock(childBlock)
					}
				}
			}
			if err := os.WriteFile(savePath, hclwrite.Format(f.Bytes()), 0644); err != nil {
				return err
			}

			log.Success(fmt.Sprintf("Graft manifest saved to %s", savePath))
			return nil
		},
	}

	cmd.Flags().StringVarP(&outputFile, "output", "o", "", "Output file path (default: scaffold.graft.hcl)")

	return cmd
}
