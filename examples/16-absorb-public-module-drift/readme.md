# Example 16: Absorb Drift on a Public Registry Module

This example demonstrates how to use `graft absorb` with a **public Terraform Registry module** (`Azure/network/azurerm`). It walks through the full workflow from detecting drift to verifying zero changes.

## Scenario

You're using the public [`Azure/network/azurerm`](https://registry.terraform.io/modules/Azure/network/azurerm/latest) module to manage a VNet with two subnets. After deployment, external changes are made:

### Root resource (Resource Group)
Azure Policy auto-added `Creator` and `DateCreated` tags, and a team member promoted the environment:
```bash
az group update --name graft-absorb-module-rg \
  --tags environment=production project=graft owner=platform-team
```

### Inside the public module (VNet)
Tags changed to match the promoted environment:
```bash
az network vnet update --resource-group graft-absorb-module-rg \
  --name graft-example-vnet \
  --set tags.environment=production tags.owner=platform-team
```

### Inside the public module (Subnet)
A service endpoint was added and outbound access disabled on `web-subnet`:
```bash
az network vnet subnet update --resource-group graft-absorb-module-rg \
  --vnet-name graft-example-vnet --name web-subnet \
  --service-endpoints Microsoft.Web \
  --default-outbound-access false
```

Running `terraform plan` now shows 3 resources with drift — 1 at the root and 2 inside the public module.

## Why This Matters

When drift occurs **inside a public module**, you can't simply edit the module's source code — it's managed by the registry. `graft absorb` generates an override manifest that patches the module from the outside, without forking it.

## Files

- `main.tf`: Root Terraform configuration using the public `Azure/network/azurerm` module.
- `plan.json`: Terraform plan JSON output showing drift on 3 resources.
- `absorb.graft.hcl`: The generated graft manifest (output of `graft absorb`).

## Usage

### Step 1: Initialize and deploy your infrastructure

```bash
terraform init
terraform apply
```

### Step 2: Drift happens externally

Tags are changed, service endpoints added, settings modified — either manually, by Azure Policy, or by another team. Your Terraform config is now out of sync with the actual state.

### Step 3: Generate a Terraform plan and export as JSON

```bash
terraform plan -out=tfplan
terraform show -json tfplan > plan.json
```

The plan output shows the drift Terraform wants to revert:

```
  # azurerm_resource_group.example will be updated in-place
  ~ resource "azurerm_resource_group" "example" {
        id       = "/subscriptions/.../resourceGroups/graft-absorb-module-rg"
        name     = "graft-absorb-module-rg"
      ~ tags     = {
          - "Creator"     = "admin@contoso.com" -> null
          - "DateCreated" = "2026-01-15T09:22:31Z" -> null
          ~ "environment" = "production" -> "dev"
          - "owner"       = "platform-team" -> null
            # (1 unchanged element hidden)
        }
    }

  # module.network.azurerm_virtual_network.vnet will be updated in-place
  ~ resource "azurerm_virtual_network" "vnet" {
        id                  = "/subscriptions/.../virtualNetworks/graft-example-vnet"
        name                = "graft-example-vnet"
      ~ tags                = {
          ~ "environment" = "production" -> "dev"
          - "owner"       = "platform-team" -> null
            # (1 unchanged element hidden)
        }
    }

  # module.network.azurerm_subnet.subnet_for_each["web-subnet"] will be updated in-place
  ~ resource "azurerm_subnet" "subnet_for_each" {
        id                              = "/subscriptions/.../subnets/web-subnet"
        name                            = "web-subnet"
      ~ default_outbound_access_enabled = false -> true
      ~ service_endpoints               = [
          - "Microsoft.Web",
        ]
    }

Plan: 0 to add, 3 to change, 0 to destroy.
```

### Step 4: Run `graft absorb`

```bash
graft absorb plan.json
```

Output:
```
[+] Fetching providers schema...
[+] Reading Terraform plan JSON...
[+] Found 3 resource(s) with drift...
    - azurerm_resource_group.example
    - module.network.azurerm_virtual_network.vnet
    - module.network.azurerm_subnet.subnet_for_each["web-subnet"]
[+] Generating manifest...
✨ Manifest saved to ./absorb.graft.hcl
```

### Step 5: Review the generated manifest

The generated `absorb.graft.hcl`:

```hcl
# Generated by graft absorb
# This manifest contains overrides to match the current remote state

override {
  # Absorb drift for: azurerm_resource_group.example
  resource "azurerm_resource_group" "example" {
    tags = {
      Creator     = "admin@contoso.com"
      DateCreated = "2026-01-15T09:22:31Z"
      environment = "production"
      owner       = "platform-team"
      project     = "graft"
    }
  }
}

module "network" {
  override {
    # Absorb drift for: module.network.azurerm_virtual_network.vnet
    resource "azurerm_virtual_network" "vnet" {
      tags = {
        environment = "production"
        managed_by  = "terraform"
        owner       = "platform-team"
      }
    }

    # Absorb drift for: module.network.azurerm_subnet.subnet_for_each["web-subnet"]
    resource "azurerm_subnet" "subnet_for_each" {
      default_outbound_access_enabled = lookup({
        web-subnet = false
      }, each.key, graft.source)
      service_endpoints = lookup({
        web-subnet = ["Microsoft.Web"]
      }, each.key, graft.source)
    }
  }
}
```

Key things to notice:

- **Root-level drift** (`azurerm_resource_group.example`) is handled with a simple `override` block.
- **Module-level drift** is wrapped in `module "network" { override { ... } }` — graft patches the public module from the outside.
- **`for_each` resource** (`azurerm_subnet.subnet_for_each`) uses `lookup()` keyed by `each.key` so only the drifted instance (`"web-subnet"`) is overridden. The `app-subnet` instance uses `graft.source` (the original value) because it has no drift.

### Step 6: Build and verify

```bash
graft build
terraform plan
```

Expected output:
```
No changes. Your infrastructure matches the configuration.
```

The drift has been absorbed — Terraform now treats the external changes as the desired state.

## Flags Reference

| Flag | Short | Description |
|------|-------|-------------|
| `--output` | `-o` | Output file path (default: `absorb.graft.hcl`) |
| `--providers-schema` | `-p` | Path to a pre-generated providers schema JSON file |

### Using a pre-generated providers schema

By default, `graft absorb` runs `terraform providers schema -json` automatically. If you want to skip that (e.g., in CI or if Terraform isn't initialized), you can provide one:

```bash
terraform providers schema -json > providers.json
graft absorb -p providers.json plan.json
```

The providers schema helps `graft absorb` filter out **computed-only attributes** (like `id`, `timeouts`) from the generated manifest, producing cleaner output.

