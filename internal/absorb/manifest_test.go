package absorb

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/hashicorp/hcl/v2/hclwrite"
	tfjson "github.com/hashicorp/terraform-json"
	"github.com/ms-henglu/graft/internal/utils"
	"github.com/zclconf/go-cty/cty"
)

// expectManifest is a test helper that compares the actual manifest output with the expected string,
// normalizing whitespace for comparison.
func expectManifest(t *testing.T, actual []byte, expected string) {
	t.Helper()
	actualStr := strings.TrimSpace(string(actual))
	expectedStr := strings.TrimSpace(expected)
	if normalizeWhitespace(actualStr) != normalizeWhitespace(expectedStr) {
		t.Errorf("manifest mismatch.\nExpected:\n%s\n\nActual:\n%s", expectedStr, actualStr)
	}
}

// expectBlock is a test helper that renders an hclwrite.Block and compares it with expected output.
func expectBlock(t *testing.T, block *hclwrite.Block, expected string) {
	t.Helper()
	f := hclwrite.NewEmptyFile()
	f.Body().AppendBlock(block)
	actual := strings.TrimSpace(string(hclwrite.Format(f.Bytes())))
	expectedStr := strings.TrimSpace(expected)
	if normalizeWhitespace(actual) != normalizeWhitespace(expectedStr) {
		t.Errorf("block mismatch.\nExpected:\n%s\n\nActual:\n%s", expectedStr, actual)
	}
}

// normalizeWhitespace collapses all runs of whitespace into a single space.
func normalizeWhitespace(s string) string {
	fields := strings.Fields(s)
	return strings.Join(fields, " ")
}

// writeSchemaFile is a test helper that writes a provider schema JSON to a temp dir and returns the path.
func writeSchemaFile(t *testing.T, schemasJSON string) string {
	t.Helper()
	tmpDir := t.TempDir()
	sf := filepath.Join(tmpDir, "providers.json")
	if err := os.WriteFile(sf, []byte(schemasJSON), 0644); err != nil {
		t.Fatalf("Failed to write schemas file: %v", err)
	}
	return sf
}

func TestGenerateManifest(t *testing.T) {
	result := []DriftChange{
		{
			Address:      "module.network.azurerm_virtual_network.vnet",
			ModulePath:   []string{"network"},
			ResourceType: "azurerm_virtual_network",
			ResourceName: "vnet",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Mode:         "managed",
			ChangedAttrs: map[string]interface{}{
				"tags": map[string]interface{}{
					"Env": "Prod",
				},
			},
		},
	}

	manifest, err := GenerateManifest(result, "")
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	expectManifest(t, manifest, `
# Generated by graft absorb
# This manifest contains overrides to match the current remote state

module "network" {
  override {
    # Absorb drift for: module.network.azurerm_virtual_network.vnet
    resource "azurerm_virtual_network" "vnet" {
      tags = {
        Env = "Prod"
      }
    }

  }
}
`)
}

func TestGenerateManifestNestedModules(t *testing.T) {
	result := []DriftChange{
		{
			Address:      "module.network.module.subnet.azurerm_subnet.main",
			ModulePath:   []string{"network", "subnet"},
			ResourceType: "azurerm_subnet",
			ResourceName: "main",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Mode:         "managed",
			ChangedAttrs: map[string]interface{}{
				"address_prefixes": []interface{}{"10.0.1.0/24"},
			},
		},
	}

	manifest, err := GenerateManifest(result, "")
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	expectManifest(t, manifest, `
# Generated by graft absorb
# This manifest contains overrides to match the current remote state

module "network" {
  module "subnet" {
    override {
      # Absorb drift for: module.network.module.subnet.azurerm_subnet.main
      resource "azurerm_subnet" "main" {
        address_prefixes = ["10.0.1.0/24"]
      }

    }
  }

}
`)
}

func TestGenerateManifestWithBlockType(t *testing.T) {
	schemasJSON := `{
		"format_version": "1.0",
		"provider_schemas": {
			"registry.terraform.io/hashicorp/azurerm": {
				"resource_schemas": {
					"azurerm_virtual_network": {
						"version": 0,
						"block": {
							"attributes": {
								"name": { "type": "string", "required": true }
							},
							"block_types": {
								"ddos_protection_plan": {
									"nesting_mode": "list",
									"block": {
										"attributes": {
											"enable": { "type": "bool", "required": true },
											"id": { "type": "string", "required": true }
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}`

	sf := writeSchemaFile(t, schemasJSON)

	result := []DriftChange{
		{
			Address:      "module.network.azurerm_virtual_network.main",
			ModulePath:   []string{"network"},
			ResourceType: "azurerm_virtual_network",
			ResourceName: "main",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Mode:         "managed",
			ChangedAttrs: map[string]interface{}{
				"ddos_protection_plan": []interface{}{
					map[string]interface{}{
						"enable": true,
						"id":     "/some/id",
					},
				},
			},
		},
	}

	manifest, err := GenerateManifest(result, sf)
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	expectManifest(t, manifest, `
# Generated by graft absorb
# This manifest contains overrides to match the current remote state

module "network" {
  override {
    # Absorb drift for: module.network.azurerm_virtual_network.main
    resource "azurerm_virtual_network" "main" {
      ddos_protection_plan {
        enable = true
        id     = "/some/id"
      }
    }

  }
}
`)
}

func TestGenerateManifestWithAttributeAsBlock(t *testing.T) {
	schemasJSON := `{
		"format_version": "1.0",
		"provider_schemas": {
			"registry.terraform.io/hashicorp/azurerm": {
				"resource_schemas": {
					"azurerm_virtual_network": {
						"version": 0,
						"block": {
							"attributes": {
								"subnet": {
									"type": ["set", ["object", {
										"name": "string",
										"address_prefixes": ["list", "string"],
										"id": "string"
									}]],
									"optional": true,
									"computed": true
								}
							}
						}
					}
				}
			}
		}
	}`

	sf := writeSchemaFile(t, schemasJSON)

	result := []DriftChange{
		{
			Address:      "module.network.azurerm_virtual_network.main",
			ModulePath:   []string{"network"},
			ResourceType: "azurerm_virtual_network",
			ResourceName: "main",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Mode:         "managed",
			ChangedAttrs: map[string]interface{}{
				"subnet": []interface{}{
					map[string]interface{}{
						"name":             "subnet1",
						"address_prefixes": []interface{}{"10.0.1.0/24"},
						"id":               "/some/id/1",
					},
					map[string]interface{}{
						"name":             "subnet2",
						"address_prefixes": []interface{}{"10.0.2.0/24"},
						"id":               "/some/id/2",
					},
				},
			},
		},
	}

	manifest, err := GenerateManifest(result, sf)
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	expectManifest(t, manifest, `
# Generated by graft absorb
# This manifest contains overrides to match the current remote state

module "network" {
  override {
    # Absorb drift for: module.network.azurerm_virtual_network.main
    resource "azurerm_virtual_network" "main" {
      subnet {
        address_prefixes = ["10.0.1.0/24"]
        name             = "subnet1"
      }
      subnet {
        address_prefixes = ["10.0.2.0/24"]
        name             = "subnet2"
      }
      _graft {
        remove = ["subnet"]
      }
    }

  }
}
`)
}

func TestGenerateManifestSingleBlockNoGraftRemoval(t *testing.T) {
	schemasJSON := `{
		"format_version": "1.0",
		"provider_schemas": {
			"registry.terraform.io/hashicorp/azurerm": {
				"resource_schemas": {
					"azurerm_virtual_network": {
						"version": 0,
						"block": {
							"attributes": {
								"subnet": {
									"type": ["set", ["object", {
										"name": "string",
										"address_prefixes": ["list", "string"],
										"id": "string"
									}]],
									"optional": true,
									"computed": true
								}
							}
						}
					}
				}
			}
		}
	}`

	sf := writeSchemaFile(t, schemasJSON)

	result := []DriftChange{
		{
			Address:      "module.network.azurerm_virtual_network.main",
			ModulePath:   []string{"network"},
			ResourceType: "azurerm_virtual_network",
			ResourceName: "main",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Mode:         "managed",
			ChangedAttrs: map[string]interface{}{
				"subnet": []interface{}{
					map[string]interface{}{
						"name":             "subnet1",
						"address_prefixes": []interface{}{"10.0.1.0/24"},
					},
				},
			},
		},
	}

	manifest, err := GenerateManifest(result, sf)
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	expectManifest(t, manifest, `
# Generated by graft absorb
# This manifest contains overrides to match the current remote state

module "network" {
  override {
    # Absorb drift for: module.network.azurerm_virtual_network.main
    resource "azurerm_virtual_network" "main" {
      subnet {
        address_prefixes = ["10.0.1.0/24"]
        name             = "subnet1"
      }
    }

  }
}
`)
}

func TestGenerateManifestWithoutSchema(t *testing.T) {
	result := []DriftChange{
		{
			Address:      "module.network.azurerm_virtual_network.main",
			ModulePath:   []string{"network"},
			ResourceType: "azurerm_virtual_network",
			ResourceName: "main",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Mode:         "managed",
			ChangedAttrs: map[string]interface{}{
				"tags": map[string]interface{}{
					"Env": "Dev",
				},
			},
		},
	}

	manifest, err := GenerateManifest(result, "")
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	expectManifest(t, manifest, `
# Generated by graft absorb
# This manifest contains overrides to match the current remote state

module "network" {
  override {
    # Absorb drift for: module.network.azurerm_virtual_network.main
    resource "azurerm_virtual_network" "main" {
      tags = {
        Env = "Dev"
      }
    }

  }
}
`)
}

func TestGenerateManifestSchemaFileNotFound(t *testing.T) {
	result := []DriftChange{
		{
			Address:      "azurerm_resource_group.main",
			ResourceType: "azurerm_resource_group",
			ResourceName: "main",
			ChangedAttrs: map[string]interface{}{"location": "westus"},
		},
	}

	_, err := GenerateManifest(result, "/nonexistent/providers.json")
	if err == nil {
		t.Error("expected error for non-existent schema file")
	}
	if !strings.Contains(err.Error(), "failed to read providers schema file") {
		t.Errorf("expected 'failed to read providers schema file' error, got: %v", err)
	}
}

func TestGenerateManifestInvalidSchemaJSON(t *testing.T) {
	sf := writeSchemaFile(t, "not json")

	result := []DriftChange{
		{
			Address:      "azurerm_resource_group.main",
			ResourceType: "azurerm_resource_group",
			ResourceName: "main",
			ChangedAttrs: map[string]interface{}{"location": "westus"},
		},
	}

	_, err := GenerateManifest(result, sf)
	if err == nil {
		t.Error("expected error for invalid JSON")
	}
	if !strings.Contains(err.Error(), "failed to parse providers schema JSON") {
		t.Errorf("expected 'failed to parse providers schema JSON' error, got: %v", err)
	}
}

func TestGenerateManifestWithSchemaFile(t *testing.T) {
	planJSON := `{
		"format_version": "1.0",
		"terraform_version": "1.5.0",
		"resource_changes": [
			{
				"address": "module.network.azurerm_virtual_network.main",
				"module_address": "module.network",
				"mode": "managed",
				"type": "azurerm_virtual_network",
				"name": "main",
				"provider_name": "registry.terraform.io/hashicorp/azurerm",
				"change": {
					"actions": ["update"],
					"before": {
						"name": "my-vnet",
						"subnet": [
							{"name": "subnet1", "address_prefixes": ["10.0.5.0/24"], "id": "new-id"}
						]
					},
					"after": {
						"name": "my-vnet",
						"subnet": [
							{"name": "subnet1", "address_prefixes": ["10.0.1.0/24"], "id": "old-id"}
						]
					}
				}
			}
		]
	}`

	schemasJSON := `{
		"format_version": "1.0",
		"provider_schemas": {
			"registry.terraform.io/hashicorp/azurerm": {
				"resource_schemas": {
					"azurerm_virtual_network": {
						"version": 0,
						"block": {
							"attributes": {
								"name": {
									"type": "string",
									"required": true
								},
								"guid": {
									"type": "string",
									"computed": true
								},
								"subnet": {
									"type": ["set", ["object", {
										"name": "string",
										"address_prefixes": ["list", "string"],
										"id": "string"
									}]],
									"optional": true,
									"computed": true
								}
							}
						}
					}
				}
			}
		}
	}`

	tmpDir := t.TempDir()
	planFile := filepath.Join(tmpDir, "plan.json")
	schemasFile := filepath.Join(tmpDir, "providers.json")

	if err := os.WriteFile(planFile, []byte(planJSON), 0644); err != nil {
		t.Fatalf("Failed to write plan file: %v", err)
	}
	if err := os.WriteFile(schemasFile, []byte(schemasJSON), 0644); err != nil {
		t.Fatalf("Failed to write schemas file: %v", err)
	}

	result, err := ParsePlanFile(planFile)
	if err != nil {
		t.Fatalf("ParsePlanFile failed: %v", err)
	}

	if len(result) != 1 {
		t.Fatalf("expected 1 change, got %d", len(result))
	}

	manifest, err := GenerateManifest(result, schemasFile)
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	expectManifest(t, manifest, `
# Generated by graft absorb
# This manifest contains overrides to match the current remote state

module "network" {
  override {
    # Absorb drift for: module.network.azurerm_virtual_network.main
    resource "azurerm_virtual_network" "main" {
      subnet {
        address_prefixes = ["10.0.5.0/24"]
      }
    }

  }
}
`)
}

func TestDriftChangeToBlock(t *testing.T) {
	tests := []struct {
		name      string
		change    DriftChange
		schema    *tfjson.SchemaBlock
		expected  string
		expectNil bool
	}{
		{
			name: "simple attributes without schema",
			change: DriftChange{
				ResourceType: "azurerm_resource_group",
				ResourceName: "main",
				ChangedAttrs: map[string]interface{}{
					"tags": map[string]interface{}{"Env": "Prod"},
				},
			},
			schema: nil,
			expected: `
resource "azurerm_resource_group" "main" {
  tags = {
    Env = "Prod"
  }
}`,
		},
		{
			name: "filters computed-only attributes with schema",
			change: DriftChange{
				ResourceType: "azurerm_virtual_network",
				ResourceName: "main",
				ProviderName: "registry.terraform.io/hashicorp/azurerm",
				ChangedAttrs: map[string]interface{}{
					"name": "changed",
					"guid": "computed-value",
				},
			},
			schema: &tfjson.SchemaBlock{
				Attributes: map[string]*tfjson.SchemaAttribute{
					"name": {Optional: true},
					"guid": {Computed: true},
				},
			},
			expected: `
resource "azurerm_virtual_network" "main" {
  name = "changed"
}`,
		},
		{
			name: "renders block_type as block syntax",
			change: DriftChange{
				ResourceType: "azurerm_virtual_network",
				ResourceName: "main",
				ChangedAttrs: map[string]interface{}{
					"ddos_protection_plan": []interface{}{
						map[string]interface{}{
							"enable": true,
							"id":     "/some/id",
						},
					},
				},
			},
			schema: &tfjson.SchemaBlock{
				NestedBlocks: map[string]*tfjson.SchemaBlockType{
					"ddos_protection_plan": {
						NestingMode: tfjson.SchemaNestingModeList,
						Block: &tfjson.SchemaBlock{
							Attributes: map[string]*tfjson.SchemaAttribute{
								"enable": {Required: true},
								"id":     {Required: true},
							},
						},
					},
				},
			},
			expected: `
resource "azurerm_virtual_network" "main" {
  ddos_protection_plan {
    enable = true
    id     = "/some/id"
  }
}`,
		},
		{
			name: "renders attribute-as-block with computed filtering and _graft removal",
			change: DriftChange{
				ResourceType: "azurerm_virtual_network",
				ResourceName: "main",
				ChangedAttrs: map[string]interface{}{
					"subnet": []interface{}{
						map[string]interface{}{
							"name": "subnet1",
							"id":   "/computed/id/1",
						},
						map[string]interface{}{
							"name": "subnet2",
							"id":   "/computed/id/2",
						},
					},
				},
			},
			schema: &tfjson.SchemaBlock{
				Attributes: map[string]*tfjson.SchemaAttribute{
					"subnet": {
						AttributeType: cty.Set(cty.Object(map[string]cty.Type{
							"name": cty.String,
							"id":   cty.String,
						})),
						Optional: true,
						Computed: true,
					},
				},
			},
			expected: `
resource "azurerm_virtual_network" "main" {
  subnet {
    name = "subnet1"
  }
  subnet {
    name = "subnet2"
  }
  _graft {
    remove = ["subnet"]
  }
}`,
		},
		{
			name: "single block no _graft removal",
			change: DriftChange{
				ResourceType: "azurerm_virtual_network",
				ResourceName: "main",
				ChangedAttrs: map[string]interface{}{
					"subnet": []interface{}{
						map[string]interface{}{"name": "subnet1"},
					},
				},
			},
			schema: &tfjson.SchemaBlock{
				Attributes: map[string]*tfjson.SchemaAttribute{
					"subnet": {
						AttributeType: cty.Set(cty.Object(map[string]cty.Type{
							"name": cty.String,
						})),
						Optional: true,
						Computed: true,
					},
				},
			},
			expected: `
resource "azurerm_virtual_network" "main" {
  subnet {
    name = "subnet1"
  }
}`,
		},
		{
			name: "returns nil when all attributes are computed",
			change: DriftChange{
				ResourceType: "azurerm_resource_group",
				ResourceName: "main",
				ChangedAttrs: map[string]interface{}{
					"id":   "/some/id",
					"guid": "some-guid",
				},
			},
			schema: &tfjson.SchemaBlock{
				Attributes: map[string]*tfjson.SchemaAttribute{
					"id":   {Computed: true},
					"guid": {Computed: true},
				},
			},
			expectNil: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			block := tt.change.ToBlock(tt.schema)
			if tt.expectNil {
				if block != nil {
					t.Errorf("expected nil block, got non-nil")
				}
				return
			}
			if block == nil {
				t.Fatal("expected non-nil block")
			}
			expectBlock(t, block, tt.expected)
		})
	}
}

func TestInterfaceToCtyValue(t *testing.T) {
	tests := []struct {
		name  string
		input interface{}
	}{
		{"nil", nil},
		{"bool true", true},
		{"bool false", false},
		{"integer", float64(42)},
		{"float", 3.14},
		{"string", "hello"},
		{"empty slice", []interface{}{}},
		{"slice", []interface{}{"a", "b"}},
		{"empty map", map[string]interface{}{}},
		{"map", map[string]interface{}{"key": "value"}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := utils.ToCtyValue(tt.input)
			if result.IsNull() && tt.input != nil {
				if tt.name != "nil" && tt.name != "empty slice" && tt.name != "empty map" {
					t.Errorf("unexpected null value for %v", tt.input)
				}
			}
		})
	}
}

func TestIsComputedOnly(t *testing.T) {
	tests := []struct {
		name     string
		attr     *tfjson.SchemaAttribute
		expected bool
	}{
		{"nil attr", nil, false},
		{"computed only", &tfjson.SchemaAttribute{Computed: true}, true},
		{"optional+computed", &tfjson.SchemaAttribute{Computed: true, Optional: true}, false},
		{"required+computed", &tfjson.SchemaAttribute{Computed: true, Required: true}, false},
		{"optional only", &tfjson.SchemaAttribute{Optional: true}, false},
		{"required only", &tfjson.SchemaAttribute{Required: true}, false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := isComputedOnly(tt.attr)
			if result != tt.expected {
				t.Errorf("expected %v, got %v", tt.expected, result)
			}
		})
	}
}

func TestFilterComputedAttrs(t *testing.T) {
	schema := &tfjson.SchemaBlock{
		Attributes: map[string]*tfjson.SchemaAttribute{
			"name": {Optional: true},
			"guid": {Computed: true},
			"subnet": {
				AttributeType: cty.Set(cty.Object(map[string]cty.Type{
					"name":             cty.String,
					"address_prefixes": cty.List(cty.String),
					"id":               cty.String,
				})),
				Optional: true,
				Computed: true,
			},
		},
	}

	attrs := map[string]interface{}{
		"name": "changed",
		"guid": "computed-value",
		"subnet": []interface{}{
			map[string]interface{}{
				"name":             "subnet1",
				"address_prefixes": []interface{}{"10.0.1.0/24"},
				"id":               "/computed/id",
			},
		},
	}

	r := filterComputedAttrs(attrs, schema, "")
	result, _ := r.(map[string]interface{})

	// guid should be filtered out (computed-only)
	if _, hasGuid := result["guid"]; hasGuid {
		t.Error("expected 'guid' to be filtered out")
	}

	// name should be kept
	if _, hasName := result["name"]; !hasName {
		t.Error("expected 'name' to be present")
	}

	// subnet should be present with id filtered out
	subnet, ok := result["subnet"]
	if !ok {
		t.Fatal("expected subnet in result")
	}
	arr, ok := subnet.([]interface{})
	if !ok {
		t.Fatalf("expected []interface{}, got %T", subnet)
	}
	item, ok := arr[0].(map[string]interface{})
	if !ok {
		t.Fatalf("expected map, got %T", arr[0])
	}
	if _, hasID := item["id"]; hasID {
		t.Error("expected 'id' to be filtered out from subnet")
	}
}

func TestToBlocks(t *testing.T) {
	t.Run("map value produces single block", func(t *testing.T) {
		blocks := toBlocks("config", map[string]interface{}{
			"key":   "setting1",
			"value": "val1",
		}, nil)

		if len(blocks) != 1 {
			t.Fatalf("expected 1 block, got %d", len(blocks))
		}

		f := hclwrite.NewEmptyFile()
		f.Body().AppendBlock(blocks[0])
		result := string(hclwrite.Format(f.Bytes()))

		if !strings.Contains(result, "config {") {
			t.Errorf("expected 'config {', got:\n%s", result)
		}
		if !strings.Contains(result, `key`) {
			t.Errorf("expected 'key' attr, got:\n%s", result)
		}
	})

	t.Run("slice value produces multiple blocks", func(t *testing.T) {
		blocks := toBlocks("item", []interface{}{
			map[string]interface{}{"name": "a"},
			map[string]interface{}{"name": "b"},
		}, nil)

		if len(blocks) != 2 {
			t.Fatalf("expected 2 blocks, got %d", len(blocks))
		}
	})

	t.Run("skips nil and empty string values in blocks", func(t *testing.T) {
		blocks := toBlocks("config", map[string]interface{}{
			"key":     "setting1",
			"empty":   "",
			"nothing": nil,
		}, nil)

		if len(blocks) != 1 {
			t.Fatalf("expected 1 block, got %d", len(blocks))
		}

		f := hclwrite.NewEmptyFile()
		f.Body().AppendBlock(blocks[0])
		result := string(hclwrite.Format(f.Bytes()))

		if strings.Contains(result, "empty") {
			t.Errorf("expected 'empty' to be skipped, got:\n%s", result)
		}
		if strings.Contains(result, "nothing") {
			t.Errorf("expected 'nothing' to be skipped, got:\n%s", result)
		}
	})

	t.Run("recursively renders nested blocks with schema", func(t *testing.T) {
		schema := &tfjson.SchemaBlock{
			NestedBlocks: map[string]*tfjson.SchemaBlockType{
				"outer": {
					NestingMode: tfjson.SchemaNestingModeList,
					Block: &tfjson.SchemaBlock{
						Attributes: map[string]*tfjson.SchemaAttribute{
							"name": {Required: true},
						},
						NestedBlocks: map[string]*tfjson.SchemaBlockType{
							"inner": {
								NestingMode: tfjson.SchemaNestingModeList,
								Block: &tfjson.SchemaBlock{
									Attributes: map[string]*tfjson.SchemaAttribute{
										"enabled": {Optional: true},
									},
								},
							},
						},
					},
				},
			},
		}

		blocks := toBlocks("outer", map[string]interface{}{
			"name": "test",
			"inner": []interface{}{
				map[string]interface{}{"enabled": true},
			},
		}, schema)

		if len(blocks) != 1 {
			t.Fatalf("expected 1 block, got %d", len(blocks))
		}

		f := hclwrite.NewEmptyFile()
		f.Body().AppendBlock(blocks[0])
		result := string(hclwrite.Format(f.Bytes()))

		if !strings.Contains(result, "inner {") {
			t.Errorf("expected nested 'inner {' block, got:\n%s", result)
		}
		if !strings.Contains(result, "enabled") {
			t.Errorf("expected 'enabled' attr in inner block, got:\n%s", result)
		}
	})

	t.Run("non-map non-slice value produces no blocks", func(t *testing.T) {
		blocks := toBlocks("attr", "just-a-string", nil)
		if len(blocks) != 0 {
			t.Errorf("expected 0 blocks for string value, got %d", len(blocks))
		}
	})
}

func TestGenerateManifestEmptyChanges(t *testing.T) {
	manifest, err := GenerateManifest([]DriftChange{}, "")
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	expectManifest(t, manifest, `
# Generated by graft absorb
# This manifest contains overrides to match the current remote state
`)
}

func TestGenerateManifestMultipleResourcesSorted(t *testing.T) {
	result := []DriftChange{
		{
			Address:      "azurerm_virtual_network.beta",
			ResourceType: "azurerm_virtual_network",
			ResourceName: "beta",
			ChangedAttrs: map[string]interface{}{"name": "beta"},
		},
		{
			Address:      "azurerm_resource_group.main",
			ResourceType: "azurerm_resource_group",
			ResourceName: "main",
			ChangedAttrs: map[string]interface{}{"location": "westus"},
		},
		{
			Address:      "azurerm_virtual_network.alpha",
			ResourceType: "azurerm_virtual_network",
			ResourceName: "alpha",
			ChangedAttrs: map[string]interface{}{"name": "alpha"},
		},
	}

	manifest, err := GenerateManifest(result, "")
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	expectManifest(t, manifest, `
# Generated by graft absorb
# This manifest contains overrides to match the current remote state

override {
  # Absorb drift for: azurerm_resource_group.main
  resource "azurerm_resource_group" "main" {
    location = "westus"
  }

  # Absorb drift for: azurerm_virtual_network.alpha
  resource "azurerm_virtual_network" "alpha" {
    name = "alpha"
  }

  # Absorb drift for: azurerm_virtual_network.beta
  resource "azurerm_virtual_network" "beta" {
    name = "beta"
  }

}
`)
}

func TestGenerateManifestCountIndexed(t *testing.T) {
	result := []DriftChange{
		{
			Address:      "azurerm_resource_group.main[0]",
			ResourceType: "azurerm_resource_group",
			ResourceName: "main",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Index:        float64(0),
			ChangedAttrs: map[string]interface{}{
				"tags": map[string]interface{}{"env": "prod"},
			},
		},
		{
			Address:      "azurerm_resource_group.main[1]",
			ResourceType: "azurerm_resource_group",
			ResourceName: "main",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Index:        float64(1),
			ChangedAttrs: map[string]interface{}{
				"tags": map[string]interface{}{"env": "staging"},
			},
		},
	}

	manifest, err := GenerateManifest(result, "")
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	expectManifest(t, manifest, `
# Generated by graft absorb
# This manifest contains overrides to match the current remote state

override {
  # Absorb drift for: azurerm_resource_group.main[0], azurerm_resource_group.main[1]
  resource "azurerm_resource_group" "main" {
    tags = lookup({
      "0" = {
        env = "prod"
      }
      "1" = {
        env = "staging"
      }
    }, count.index, graft.source)
  }

}
`)
}

func TestGenerateManifestForEachIndexed(t *testing.T) {
	result := []DriftChange{
		{
			Address:      `azurerm_resource_group.main["web"]`,
			ResourceType: "azurerm_resource_group",
			ResourceName: "main",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Index:        "web",
			ChangedAttrs: map[string]interface{}{
				"location": "eastus",
			},
		},
		{
			Address:      `azurerm_resource_group.main["api"]`,
			ResourceType: "azurerm_resource_group",
			ResourceName: "main",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Index:        "api",
			ChangedAttrs: map[string]interface{}{
				"location": "westus",
			},
		},
	}

	manifest, err := GenerateManifest(result, "")
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	expectManifest(t, manifest, `
# Generated by graft absorb
# This manifest contains overrides to match the current remote state

override {
  # Absorb drift for: azurerm_resource_group.main["web"], azurerm_resource_group.main["api"]
  resource "azurerm_resource_group" "main" {
    location = lookup({
      api = "westus"
      web = "eastus"
    }, each.key, graft.source)
  }

}
`)
}

func TestGenerateManifestCountIndexedAllSameValue(t *testing.T) {
	result := []DriftChange{
		{
			Address:      "azurerm_resource_group.main[0]",
			ResourceType: "azurerm_resource_group",
			ResourceName: "main",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Index:        float64(0),
			ChangedAttrs: map[string]interface{}{
				"tags": map[string]interface{}{"env": "prod"},
			},
		},
		{
			Address:      "azurerm_resource_group.main[1]",
			ResourceType: "azurerm_resource_group",
			ResourceName: "main",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Index:        float64(1),
			ChangedAttrs: map[string]interface{}{
				"tags": map[string]interface{}{"env": "prod"},
			},
		},
	}

	manifest, err := GenerateManifest(result, "")
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	expectManifest(t, manifest, `
# Generated by graft absorb
# This manifest contains overrides to match the current remote state

override {
  # Absorb drift for: azurerm_resource_group.main[0], azurerm_resource_group.main[1]
  resource "azurerm_resource_group" "main" {
    tags = lookup({
      "0" = {
        env = "prod"
      }
      "1" = {
        env = "prod"
      }
    }, count.index, graft.source)
  }

}
`)
}

func TestGenerateManifestMixedIndexedAndNonIndexed(t *testing.T) {
	result := []DriftChange{
		{
			Address:      "azurerm_resource_group.main[0]",
			ResourceType: "azurerm_resource_group",
			ResourceName: "main",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Index:        float64(0),
			ChangedAttrs: map[string]interface{}{
				"tags": map[string]interface{}{"env": "prod"},
			},
		},
		{
			Address:      "azurerm_virtual_network.vnet",
			ResourceType: "azurerm_virtual_network",
			ResourceName: "vnet",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			ChangedAttrs: map[string]interface{}{
				"tags": map[string]interface{}{"team": "platform"},
			},
		},
	}

	manifest, err := GenerateManifest(result, "")
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	expectManifest(t, manifest, `
# Generated by graft absorb
# This manifest contains overrides to match the current remote state

override {
  # Absorb drift for: azurerm_virtual_network.vnet
  resource "azurerm_virtual_network" "vnet" {
    tags = {
      team = "platform"
    }
  }

  # Absorb drift for: azurerm_resource_group.main[0]
  resource "azurerm_resource_group" "main" {
    tags = lookup({
      "0" = {
        env = "prod"
      }
    }, count.index, graft.source)
  }

}
`)
}

func TestGenerateManifestForEachIndexedInModule(t *testing.T) {
	result := []DriftChange{
		{
			Address:      `module.network.azurerm_subnet.main["web"]`,
			ModulePath:   []string{"network"},
			ResourceType: "azurerm_subnet",
			ResourceName: "main",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Index:        "web",
			ChangedAttrs: map[string]interface{}{
				"address_prefixes": []interface{}{"10.0.1.0/24"},
			},
		},
		{
			Address:      `module.network.azurerm_subnet.main["api"]`,
			ModulePath:   []string{"network"},
			ResourceType: "azurerm_subnet",
			ResourceName: "main",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Index:        "api",
			ChangedAttrs: map[string]interface{}{
				"address_prefixes": []interface{}{"10.0.2.0/24"},
			},
		},
	}

	manifest, err := GenerateManifest(result, "")
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	expectManifest(t, manifest, `
# Generated by graft absorb
# This manifest contains overrides to match the current remote state

module "network" {
  override {
    # Absorb drift for: module.network.azurerm_subnet.main["web"], module.network.azurerm_subnet.main["api"]
    resource "azurerm_subnet" "main" {
      address_prefixes = lookup({
        api = ["10.0.2.0/24"]
        web = ["10.0.1.0/24"]
      }, each.key, graft.source)
    }

  }
}
`)
}

func TestIndexedChangesToBlockPartialDrift(t *testing.T) {
	changes := []DriftChange{
		{
			Address:      "azurerm_resource_group.main[0]",
			ResourceType: "azurerm_resource_group",
			ResourceName: "main",
			Index:        float64(0),
			ChangedAttrs: map[string]interface{}{
				"location": "eastus",
				"tags":     map[string]interface{}{"env": "prod"},
			},
		},
		{
			Address:      "azurerm_resource_group.main[1]",
			ResourceType: "azurerm_resource_group",
			ResourceName: "main",
			Index:        float64(1),
			ChangedAttrs: map[string]interface{}{
				"tags": map[string]interface{}{"env": "staging"},
			},
		},
	}

	c := &IndexedDriftChange{
		Changes: changes,
	}
	block := c.ToBlock(nil)
	if block == nil {
		t.Fatal("expected non-nil block")
	}

	expectBlock(t, block, `
resource "azurerm_resource_group" "main" {
  location = lookup({
    "0" = "eastus"
  }, count.index, graft.source)
  tags = lookup({
    "0" = {
      env = "prod"
    }
    "1" = {
      env = "staging"
    }
  }, count.index, graft.source)
}
`)
}
