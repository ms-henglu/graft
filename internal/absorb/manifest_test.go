package absorb

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/hashicorp/hcl/v2/hclwrite"
	tfjson "github.com/hashicorp/terraform-json"
	"github.com/zclconf/go-cty/cty"
)

func TestGenerateManifest(t *testing.T) {
	result := []DriftChange{
		{
			Address:      "module.network.azurerm_virtual_network.vnet",
			ModulePath:   []string{"network"},
			ResourceType: "azurerm_virtual_network",
			ResourceName: "vnet",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Mode:         "managed",
			ChangedAttrs: map[string]interface{}{
				"tags": map[string]interface{}{
					"Env": "Prod",
				},
			},
		},
	}

	manifest, err := GenerateManifest(result, "")
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	manifestStr := string(manifest)

	expectedPatterns := []string{
		"# Generated by graft absorb",
		`module "network"`,
		"override",
		`resource "azurerm_virtual_network" "vnet"`,
		"tags",
		"Env",
		"Prod",
	}

	for _, pattern := range expectedPatterns {
		if !strings.Contains(manifestStr, pattern) {
			t.Errorf("expected manifest to contain '%s', got:\n%s", pattern, manifestStr)
		}
	}
}

func TestGenerateManifestNestedModules(t *testing.T) {
	result := []DriftChange{
		{
			Address:      "module.network.module.subnet.azurerm_subnet.main",
			ModulePath:   []string{"network", "subnet"},
			ResourceType: "azurerm_subnet",
			ResourceName: "main",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Mode:         "managed",
			ChangedAttrs: map[string]interface{}{
				"address_prefixes": []interface{}{"10.0.1.0/24"},
			},
		},
	}

	manifest, err := GenerateManifest(result, "")
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	manifestStr := string(manifest)

	expectedPatterns := []string{
		`module "network"`,
		`module "subnet"`,
		"override",
		`resource "azurerm_subnet" "main"`,
		"address_prefixes",
	}

	for _, pattern := range expectedPatterns {
		if !strings.Contains(manifestStr, pattern) {
			t.Errorf("expected manifest to contain '%s', got:\n%s", pattern, manifestStr)
		}
	}
}

func TestGenerateManifestWithBlockType(t *testing.T) {
	schemasJSON := `{
		"format_version": "1.0",
		"provider_schemas": {
			"registry.terraform.io/hashicorp/azurerm": {
				"resource_schemas": {
					"azurerm_virtual_network": {
						"version": 0,
						"block": {
							"attributes": {
								"name": { "type": "string", "required": true }
							},
							"block_types": {
								"ddos_protection_plan": {
									"nesting_mode": "list",
									"block": {
										"attributes": {
											"enable": { "type": "bool", "required": true },
											"id": { "type": "string", "required": true }
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}`

	tmpDir := t.TempDir()
	schemasFile := filepath.Join(tmpDir, "providers.json")
	if err := os.WriteFile(schemasFile, []byte(schemasJSON), 0644); err != nil {
		t.Fatalf("Failed to write schemas file: %v", err)
	}

	result := []DriftChange{
		{
			Address:      "module.network.azurerm_virtual_network.main",
			ModulePath:   []string{"network"},
			ResourceType: "azurerm_virtual_network",
			ResourceName: "main",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Mode:         "managed",
			ChangedAttrs: map[string]interface{}{
				"ddos_protection_plan": []interface{}{
					map[string]interface{}{
						"enable": true,
						"id":     "/some/id",
					},
				},
			},
		},
	}

	manifest, err := GenerateManifest(result, schemasFile)
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	manifestStr := string(manifest)

	// Should use block syntax
	if !strings.Contains(manifestStr, "ddos_protection_plan {") {
		t.Errorf("expected block syntax 'ddos_protection_plan {', got:\n%s", manifestStr)
	}

	// Single block - should NOT have _graft removal
	if strings.Contains(manifestStr, "_graft") {
		t.Errorf("expected NO _graft removal for single block, got:\n%s", manifestStr)
	}
}

func TestGenerateManifestWithAttributeAsBlock(t *testing.T) {
	schemasJSON := `{
		"format_version": "1.0",
		"provider_schemas": {
			"registry.terraform.io/hashicorp/azurerm": {
				"resource_schemas": {
					"azurerm_virtual_network": {
						"version": 0,
						"block": {
							"attributes": {
								"subnet": {
									"type": ["set", ["object", {
										"name": "string",
										"address_prefixes": ["list", "string"],
										"id": "string"
									}]],
									"optional": true,
									"computed": true
								}
							}
						}
					}
				}
			}
		}
	}`

	tmpDir := t.TempDir()
	schemasFile := filepath.Join(tmpDir, "providers.json")
	if err := os.WriteFile(schemasFile, []byte(schemasJSON), 0644); err != nil {
		t.Fatalf("Failed to write schemas file: %v", err)
	}

	result := []DriftChange{
		{
			Address:      "module.network.azurerm_virtual_network.main",
			ModulePath:   []string{"network"},
			ResourceType: "azurerm_virtual_network",
			ResourceName: "main",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Mode:         "managed",
			ChangedAttrs: map[string]interface{}{
				"subnet": []interface{}{
					map[string]interface{}{
						"name":             "subnet1",
						"address_prefixes": []interface{}{"10.0.1.0/24"},
						"id":               "/some/id/1",
					},
					map[string]interface{}{
						"name":             "subnet2",
						"address_prefixes": []interface{}{"10.0.2.0/24"},
						"id":               "/some/id/2",
					},
				},
			},
		},
	}

	manifest, err := GenerateManifest(result, schemasFile)
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	manifestStr := string(manifest)

	// Should use block syntax
	expectedPatterns := []string{
		"subnet {",
		"subnet1",
		"subnet2",
	}
	for _, pattern := range expectedPatterns {
		if !strings.Contains(manifestStr, pattern) {
			t.Errorf("expected manifest to contain '%s', got:\n%s", pattern, manifestStr)
		}
	}

	// Should NOT contain array assignment syntax
	if strings.Contains(manifestStr, "subnet = [") {
		t.Errorf("expected manifest NOT to use array syntax 'subnet = [', got:\n%s", manifestStr)
	}

	// Multiple subnets - SHOULD have _graft removal
	if !strings.Contains(manifestStr, "_graft") {
		t.Errorf("expected _graft removal for multiple blocks, got:\n%s", manifestStr)
	}
	if !strings.Contains(manifestStr, `remove`) {
		t.Errorf("expected _graft to contain remove, got:\n%s", manifestStr)
	}

	// "id" should be filtered out by schema
	if strings.Contains(manifestStr, "/some/id") {
		t.Errorf("expected 'id' to be filtered out, got:\n%s", manifestStr)
	}
}

func TestGenerateManifestSingleBlockNoGraftRemoval(t *testing.T) {
	schemasJSON := `{
		"format_version": "1.0",
		"provider_schemas": {
			"registry.terraform.io/hashicorp/azurerm": {
				"resource_schemas": {
					"azurerm_virtual_network": {
						"version": 0,
						"block": {
							"attributes": {
								"subnet": {
									"type": ["set", ["object", {
										"name": "string",
										"address_prefixes": ["list", "string"],
										"id": "string"
									}]],
									"optional": true,
									"computed": true
								}
							}
						}
					}
				}
			}
		}
	}`

	tmpDir := t.TempDir()
	schemasFile := filepath.Join(tmpDir, "providers.json")
	if err := os.WriteFile(schemasFile, []byte(schemasJSON), 0644); err != nil {
		t.Fatalf("Failed to write schemas file: %v", err)
	}

	result := []DriftChange{
		{
			Address:      "module.network.azurerm_virtual_network.main",
			ModulePath:   []string{"network"},
			ResourceType: "azurerm_virtual_network",
			ResourceName: "main",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Mode:         "managed",
			ChangedAttrs: map[string]interface{}{
				"subnet": []interface{}{
					map[string]interface{}{
						"name":             "subnet1",
						"address_prefixes": []interface{}{"10.0.1.0/24"},
					},
				},
			},
		},
	}

	manifest, err := GenerateManifest(result, schemasFile)
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	manifestStr := string(manifest)

	// Should use block syntax
	if !strings.Contains(manifestStr, "subnet {") {
		t.Errorf("expected block syntax 'subnet {', got:\n%s", manifestStr)
	}

	// Single block - should NOT have _graft removal
	if strings.Contains(manifestStr, "_graft") {
		t.Errorf("expected NO _graft removal for single block, got:\n%s", manifestStr)
	}
}

func TestGenerateManifestWithoutSchema(t *testing.T) {
	result := []DriftChange{
		{
			Address:      "module.network.azurerm_virtual_network.main",
			ModulePath:   []string{"network"},
			ResourceType: "azurerm_virtual_network",
			ResourceName: "main",
			ProviderName: "registry.terraform.io/hashicorp/azurerm",
			Mode:         "managed",
			ChangedAttrs: map[string]interface{}{
				"tags": map[string]interface{}{
					"Env": "Dev",
				},
			},
		},
	}

	manifest, err := GenerateManifest(result, "")
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	manifestStr := string(manifest)

	if !strings.Contains(manifestStr, "tags") {
		t.Errorf("expected manifest to contain 'tags', got:\n%s", manifestStr)
	}
	if !strings.Contains(manifestStr, "Env") {
		t.Errorf("expected manifest to contain 'Env', got:\n%s", manifestStr)
	}
}

func TestGenerateManifestSchemaFileNotFound(t *testing.T) {
	result := []DriftChange{
		{
			Address:      "azurerm_resource_group.main",
			ResourceType: "azurerm_resource_group",
			ResourceName: "main",
			ChangedAttrs: map[string]interface{}{"location": "westus"},
		},
	}

	_, err := GenerateManifest(result, "/nonexistent/providers.json")
	if err == nil {
		t.Error("expected error for non-existent schema file")
	}
	if !strings.Contains(err.Error(), "failed to read providers schema file") {
		t.Errorf("expected 'failed to read providers schema file' error, got: %v", err)
	}
}

func TestGenerateManifestInvalidSchemaJSON(t *testing.T) {
	tmpDir := t.TempDir()
	schemasFile := filepath.Join(tmpDir, "providers.json")
	if err := os.WriteFile(schemasFile, []byte("not json"), 0644); err != nil {
		t.Fatalf("Failed to write schemas file: %v", err)
	}

	result := []DriftChange{
		{
			Address:      "azurerm_resource_group.main",
			ResourceType: "azurerm_resource_group",
			ResourceName: "main",
			ChangedAttrs: map[string]interface{}{"location": "westus"},
		},
	}

	_, err := GenerateManifest(result, schemasFile)
	if err == nil {
		t.Error("expected error for invalid JSON")
	}
	if !strings.Contains(err.Error(), "failed to parse providers schema JSON") {
		t.Errorf("expected 'failed to parse providers schema JSON' error, got: %v", err)
	}
}

func TestGenerateManifestWithSchemaFile(t *testing.T) {
	// End-to-end test: parse plan, then generate manifest with schema
	planJSON := `{
		"format_version": "1.0",
		"terraform_version": "1.5.0",
		"resource_changes": [
			{
				"address": "module.network.azurerm_virtual_network.main",
				"module_address": "module.network",
				"mode": "managed",
				"type": "azurerm_virtual_network",
				"name": "main",
				"provider_name": "registry.terraform.io/hashicorp/azurerm",
				"change": {
					"actions": ["update"],
					"before": {
						"name": "my-vnet",
						"subnet": [
							{"name": "subnet1", "address_prefixes": ["10.0.5.0/24"], "id": "new-id"}
						]
					},
					"after": {
						"name": "my-vnet",
						"subnet": [
							{"name": "subnet1", "address_prefixes": ["10.0.1.0/24"], "id": "old-id"}
						]
					}
				}
			}
		]
	}`

	schemasJSON := `{
		"format_version": "1.0",
		"provider_schemas": {
			"registry.terraform.io/hashicorp/azurerm": {
				"resource_schemas": {
					"azurerm_virtual_network": {
						"version": 0,
						"block": {
							"attributes": {
								"name": {
									"type": "string",
									"required": true
								},
								"guid": {
									"type": "string",
									"computed": true
								},
								"subnet": {
									"type": ["set", ["object", {
										"name": "string",
										"address_prefixes": ["list", "string"],
										"id": "string"
									}]],
									"optional": true,
									"computed": true
								}
							}
						}
					}
				}
			}
		}
	}`

	tmpDir := t.TempDir()
	planFile := filepath.Join(tmpDir, "plan.json")
	schemasFile := filepath.Join(tmpDir, "providers.json")

	if err := os.WriteFile(planFile, []byte(planJSON), 0644); err != nil {
		t.Fatalf("Failed to write plan file: %v", err)
	}
	if err := os.WriteFile(schemasFile, []byte(schemasJSON), 0644); err != nil {
		t.Fatalf("Failed to write schemas file: %v", err)
	}

	// Step 1: Parse plan (no schema needed)
	result, err := ParsePlanFile(planFile)
	if err != nil {
		t.Fatalf("ParsePlanFile failed: %v", err)
	}

	if len(result) != 1 {
		t.Fatalf("expected 1 change, got %d", len(result))
	}

	// The raw change should still have "id" since ParsePlanFile doesn't filter
	change := result[0]
	subnet, ok := change.ChangedAttrs["subnet"]
	if !ok {
		t.Fatal("expected subnet in changed attrs")
	}
	subnetArr, ok := subnet.([]interface{})
	if !ok {
		t.Fatalf("expected []interface{}, got %T", subnet)
	}
	subnetItem, ok := subnetArr[0].(map[string]interface{})
	if !ok {
		t.Fatalf("expected map, got %T", subnetArr[0])
	}
	if _, hasID := subnetItem["id"]; !hasID {
		t.Error("expected 'id' to still be present in raw ParsePlanFile result")
	}

	// Step 2: Generate manifest with schema (schema filters computed attrs)
	manifest, err := GenerateManifest(result, schemasFile)
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	manifestStr := string(manifest)

	// Should use block syntax
	if !strings.Contains(manifestStr, "subnet {") {
		t.Errorf("expected block syntax, got:\n%s", manifestStr)
	}
	// Should NOT have _graft removal (only 1 subnet)
	if strings.Contains(manifestStr, "_graft") {
		t.Errorf("expected NO _graft for single subnet, got:\n%s", manifestStr)
	}
	// "id" should be filtered out by the schema during manifest generation
	if strings.Contains(manifestStr, "new-id") {
		t.Errorf("expected 'id' value to be filtered out, got:\n%s", manifestStr)
	}
}

func TestDriftChangeToBlock(t *testing.T) {
	tests := []struct {
		name             string
		change           DriftChange
		schema           *tfjson.SchemaBlock
		expectedContains []string
		expectedAbsent   []string
		expectNil        bool
	}{
		{
			name: "simple attributes without schema",
			change: DriftChange{
				Address:      "azurerm_resource_group.main",
				ResourceType: "azurerm_resource_group",
				ResourceName: "main",
				ChangedAttrs: map[string]interface{}{
					"tags": map[string]interface{}{"Env": "Prod"},
				},
			},
			schema: nil,
			expectedContains: []string{
				`resource "azurerm_resource_group" "main"`,
				"tags",
				"Env",
			},
		},
		{
			name: "filters computed-only attributes with schema",
			change: DriftChange{
				Address:      "azurerm_virtual_network.main",
				ResourceType: "azurerm_virtual_network",
				ResourceName: "main",
				ProviderName: "registry.terraform.io/hashicorp/azurerm",
				ChangedAttrs: map[string]interface{}{
					"name": "changed",
					"guid": "computed-value",
				},
			},
			schema: &tfjson.SchemaBlock{
				Attributes: map[string]*tfjson.SchemaAttribute{
					"name": {Optional: true},
					"guid": {Computed: true},
				},
			},
			expectedContains: []string{"name"},
			expectedAbsent:   []string{"guid"},
		},
		{
			name: "renders block_type as block syntax",
			change: DriftChange{
				Address:      "azurerm_virtual_network.main",
				ResourceType: "azurerm_virtual_network",
				ResourceName: "main",
				ChangedAttrs: map[string]interface{}{
					"ddos_protection_plan": []interface{}{
						map[string]interface{}{
							"enable": true,
							"id":     "/some/id",
						},
					},
				},
			},
			schema: &tfjson.SchemaBlock{
				NestedBlocks: map[string]*tfjson.SchemaBlockType{
					"ddos_protection_plan": {
						NestingMode: tfjson.SchemaNestingModeList,
						Block: &tfjson.SchemaBlock{
							Attributes: map[string]*tfjson.SchemaAttribute{
								"enable": {Required: true},
								"id":     {Required: true},
							},
						},
					},
				},
			},
			expectedContains: []string{"ddos_protection_plan {", "enable", "/some/id"},
			expectedAbsent:   []string{"_graft"}, // single block, no removal
		},
		{
			name: "renders attribute-as-block with computed filtering and _graft removal",
			change: DriftChange{
				Address:      "azurerm_virtual_network.main",
				ResourceType: "azurerm_virtual_network",
				ResourceName: "main",
				ChangedAttrs: map[string]interface{}{
					"subnet": []interface{}{
						map[string]interface{}{
							"name": "subnet1",
							"id":   "/computed/id/1",
						},
						map[string]interface{}{
							"name": "subnet2",
							"id":   "/computed/id/2",
						},
					},
				},
			},
			schema: &tfjson.SchemaBlock{
				Attributes: map[string]*tfjson.SchemaAttribute{
					"subnet": {
						AttributeType: cty.Set(cty.Object(map[string]cty.Type{
							"name": cty.String,
							"id":   cty.String,
						})),
						Optional: true,
						Computed: true,
					},
				},
			},
			expectedContains: []string{"subnet {", "subnet1", "subnet2", "_graft", "remove"},
			expectedAbsent:   []string{"/computed/id"},
		},
		{
			name: "single block no _graft removal",
			change: DriftChange{
				Address:      "azurerm_virtual_network.main",
				ResourceType: "azurerm_virtual_network",
				ResourceName: "main",
				ChangedAttrs: map[string]interface{}{
					"subnet": []interface{}{
						map[string]interface{}{"name": "subnet1"},
					},
				},
			},
			schema: &tfjson.SchemaBlock{
				Attributes: map[string]*tfjson.SchemaAttribute{
					"subnet": {
						AttributeType: cty.Set(cty.Object(map[string]cty.Type{
							"name": cty.String,
						})),
						Optional: true,
						Computed: true,
					},
				},
			},
			expectedContains: []string{"subnet {", "subnet1"},
			expectedAbsent:   []string{"_graft"},
		},
		{
			name: "returns nil when all attributes are computed",
			change: DriftChange{
				Address:      "azurerm_resource_group.main",
				ResourceType: "azurerm_resource_group",
				ResourceName: "main",
				ChangedAttrs: map[string]interface{}{
					"id":   "/some/id",
					"guid": "some-guid",
				},
			},
			schema: &tfjson.SchemaBlock{
				Attributes: map[string]*tfjson.SchemaAttribute{
					"id":   {Computed: true},
					"guid": {Computed: true},
				},
			},
			expectNil: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			block := tt.change.ToBlock(tt.schema)
			if tt.expectNil {
				if block != nil {
					t.Errorf("expected nil block, got non-nil")
				}
				return
			}
			if block == nil {
				t.Fatal("expected non-nil block")
			}

			// Render block to string for assertions
			f := hclwrite.NewEmptyFile()
			f.Body().AppendBlock(block)
			result := string(hclwrite.Format(f.Bytes()))

			for _, pattern := range tt.expectedContains {
				if !strings.Contains(result, pattern) {
					t.Errorf("expected block to contain '%s', got:\n%s", pattern, result)
				}
			}
			for _, pattern := range tt.expectedAbsent {
				if strings.Contains(result, pattern) {
					t.Errorf("expected block NOT to contain '%s', got:\n%s", pattern, result)
				}
			}
		})
	}
}

func TestInterfaceToCtyValue(t *testing.T) {
	tests := []struct {
		name  string
		input interface{}
	}{
		{"nil", nil},
		{"bool true", true},
		{"bool false", false},
		{"integer", float64(42)},
		{"float", 3.14},
		{"string", "hello"},
		{"empty slice", []interface{}{}},
		{"slice", []interface{}{"a", "b"}},
		{"empty map", map[string]interface{}{}},
		{"map", map[string]interface{}{"key": "value"}},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := interfaceToCtyValue(tt.input)
			if result.IsNull() && tt.input != nil {
				if tt.name != "nil" && tt.name != "empty slice" && tt.name != "empty map" {
					t.Errorf("unexpected null value for %v", tt.input)
				}
			}
		})
	}
}

func TestIsComputedOnly(t *testing.T) {
	tests := []struct {
		name     string
		attr     *tfjson.SchemaAttribute
		expected bool
	}{
		{"nil attr", nil, false},
		{"computed only", &tfjson.SchemaAttribute{Computed: true}, true},
		{"optional+computed", &tfjson.SchemaAttribute{Computed: true, Optional: true}, false},
		{"required+computed", &tfjson.SchemaAttribute{Computed: true, Required: true}, false},
		{"optional only", &tfjson.SchemaAttribute{Optional: true}, false},
		{"required only", &tfjson.SchemaAttribute{Required: true}, false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := isComputedOnly(tt.attr)
			if result != tt.expected {
				t.Errorf("expected %v, got %v", tt.expected, result)
			}
		})
	}
}

func TestFilterComputedAttrs(t *testing.T) {
	schema := &tfjson.SchemaBlock{
		Attributes: map[string]*tfjson.SchemaAttribute{
			"name": {Optional: true},
			"guid": {Computed: true},
			"subnet": {
				AttributeType: cty.Set(cty.Object(map[string]cty.Type{
					"name":             cty.String,
					"address_prefixes": cty.List(cty.String),
					"id":               cty.String,
				})),
				Optional: true,
				Computed: true,
			},
		},
	}

	attrs := map[string]interface{}{
		"name": "changed",
		"guid": "computed-value",
		"subnet": []interface{}{
			map[string]interface{}{
				"name":             "subnet1",
				"address_prefixes": []interface{}{"10.0.1.0/24"},
				"id":               "/computed/id",
			},
		},
	}

	r := filterComputedAttrs(attrs, schema, "")
	result, _ := r.(map[string]interface{})

	// guid should be filtered out (computed-only)
	if _, hasGuid := result["guid"]; hasGuid {
		t.Error("expected 'guid' to be filtered out")
	}

	// name should be kept
	if _, hasName := result["name"]; !hasName {
		t.Error("expected 'name' to be present")
	}

	// subnet should be present with id filtered out
	subnet, ok := result["subnet"]
	if !ok {
		t.Fatal("expected subnet in result")
	}
	arr, ok := subnet.([]interface{})
	if !ok {
		t.Fatalf("expected []interface{}, got %T", subnet)
	}
	item, ok := arr[0].(map[string]interface{})
	if !ok {
		t.Fatalf("expected map, got %T", arr[0])
	}
	if _, hasID := item["id"]; hasID {
		t.Error("expected 'id' to be filtered out from subnet")
	}
}

func TestToBlocks(t *testing.T) {
	t.Run("map value produces single block", func(t *testing.T) {
		blocks := toBlocks("config", map[string]interface{}{
			"key":   "setting1",
			"value": "val1",
		}, nil)

		if len(blocks) != 1 {
			t.Fatalf("expected 1 block, got %d", len(blocks))
		}

		f := hclwrite.NewEmptyFile()
		f.Body().AppendBlock(blocks[0])
		result := string(hclwrite.Format(f.Bytes()))

		if !strings.Contains(result, "config {") {
			t.Errorf("expected 'config {', got:\n%s", result)
		}
		if !strings.Contains(result, `key`) {
			t.Errorf("expected 'key' attr, got:\n%s", result)
		}
	})

	t.Run("slice value produces multiple blocks", func(t *testing.T) {
		blocks := toBlocks("item", []interface{}{
			map[string]interface{}{"name": "a"},
			map[string]interface{}{"name": "b"},
		}, nil)

		if len(blocks) != 2 {
			t.Fatalf("expected 2 blocks, got %d", len(blocks))
		}
	})

	t.Run("skips nil and empty string values in blocks", func(t *testing.T) {
		blocks := toBlocks("config", map[string]interface{}{
			"key":     "setting1",
			"empty":   "",
			"nothing": nil,
		}, nil)

		if len(blocks) != 1 {
			t.Fatalf("expected 1 block, got %d", len(blocks))
		}

		f := hclwrite.NewEmptyFile()
		f.Body().AppendBlock(blocks[0])
		result := string(hclwrite.Format(f.Bytes()))

		if strings.Contains(result, "empty") {
			t.Errorf("expected 'empty' to be skipped, got:\n%s", result)
		}
		if strings.Contains(result, "nothing") {
			t.Errorf("expected 'nothing' to be skipped, got:\n%s", result)
		}
	})

	t.Run("recursively renders nested blocks with schema", func(t *testing.T) {
		schema := &tfjson.SchemaBlock{
			NestedBlocks: map[string]*tfjson.SchemaBlockType{
				"outer": {
					NestingMode: tfjson.SchemaNestingModeList,
					Block: &tfjson.SchemaBlock{
						Attributes: map[string]*tfjson.SchemaAttribute{
							"name": {Required: true},
						},
						NestedBlocks: map[string]*tfjson.SchemaBlockType{
							"inner": {
								NestingMode: tfjson.SchemaNestingModeList,
								Block: &tfjson.SchemaBlock{
									Attributes: map[string]*tfjson.SchemaAttribute{
										"enabled": {Optional: true},
									},
								},
							},
						},
					},
				},
			},
		}

		blocks := toBlocks("outer", map[string]interface{}{
			"name": "test",
			"inner": []interface{}{
				map[string]interface{}{"enabled": true},
			},
		}, schema)

		if len(blocks) != 1 {
			t.Fatalf("expected 1 block, got %d", len(blocks))
		}

		f := hclwrite.NewEmptyFile()
		f.Body().AppendBlock(blocks[0])
		result := string(hclwrite.Format(f.Bytes()))

		if !strings.Contains(result, "inner {") {
			t.Errorf("expected nested 'inner {' block, got:\n%s", result)
		}
		if !strings.Contains(result, "enabled") {
			t.Errorf("expected 'enabled' attr in inner block, got:\n%s", result)
		}
	})

	t.Run("non-map non-slice value produces no blocks", func(t *testing.T) {
		blocks := toBlocks("attr", "just-a-string", nil)
		if len(blocks) != 0 {
			t.Errorf("expected 0 blocks for string value, got %d", len(blocks))
		}
	})
}

func TestGenerateManifestEmptyChanges(t *testing.T) {
	manifest, err := GenerateManifest([]DriftChange{}, "")
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	manifestStr := string(manifest)

	// Should still have the generated-by comment
	if !strings.Contains(manifestStr, "# Generated by graft absorb") {
		t.Errorf("expected generated-by comment, got:\n%s", manifestStr)
	}
}

func TestGenerateManifestMultipleResourcesSorted(t *testing.T) {
	result := []DriftChange{
		{
			Address:      "azurerm_virtual_network.beta",
			ResourceType: "azurerm_virtual_network",
			ResourceName: "beta",
			ChangedAttrs: map[string]interface{}{"name": "beta"},
		},
		{
			Address:      "azurerm_resource_group.main",
			ResourceType: "azurerm_resource_group",
			ResourceName: "main",
			ChangedAttrs: map[string]interface{}{"location": "westus"},
		},
		{
			Address:      "azurerm_virtual_network.alpha",
			ResourceType: "azurerm_virtual_network",
			ResourceName: "alpha",
			ChangedAttrs: map[string]interface{}{"name": "alpha"},
		},
	}

	manifest, err := GenerateManifest(result, "")
	if err != nil {
		t.Fatalf("GenerateManifest failed: %v", err)
	}

	manifestStr := string(manifest)

	// azurerm_resource_group should come before azurerm_virtual_network
	rgIdx := strings.Index(manifestStr, "azurerm_resource_group")
	vnIdx := strings.Index(manifestStr, "azurerm_virtual_network")
	if rgIdx >= vnIdx {
		t.Errorf("expected azurerm_resource_group before azurerm_virtual_network, got:\n%s", manifestStr)
	}

	// alpha should come before beta
	alphaIdx := strings.Index(manifestStr, `"alpha"`)
	betaIdx := strings.Index(manifestStr, `"beta"`)
	if alphaIdx >= betaIdx {
		t.Errorf("expected alpha before beta, got:\n%s", manifestStr)
	}
}
