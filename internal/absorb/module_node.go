package absorb

import (
	"fmt"
	"sort"
	"strings"

	"github.com/hashicorp/hcl/v2/hclsyntax"
	"github.com/hashicorp/hcl/v2/hclwrite"
	tfjson "github.com/hashicorp/terraform-json"
	"github.com/ms-henglu/graft/internal/utils"
)

type ModuleItem struct {
	Name     string
	Children map[string]*ModuleItem
	Changes  []DriftChange
}

func NewModuleItem(name string) *ModuleItem {
	return &ModuleItem{
		Name:     name,
		Children: make(map[string]*ModuleItem),
		Changes:  []DriftChange{},
	}
}

func (m *ModuleItem) AddChange(change DriftChange) *ModuleItem {
	current := m
	for _, modName := range change.ModulePath {
		if _, exists := current.Children[modName]; !exists {
			current.Children[modName] = NewModuleItem(modName)
		}
		current = current.Children[modName]
	}
	current.Changes = append(current.Changes, change)
	return current
}

func (m *ModuleItem) IsRoot() bool {
	return m.Name == ""
}

func (m *ModuleItem) ToHCL(providerSchemas *tfjson.ProviderSchemas) hclwrite.Tokens {
	f := hclwrite.NewEmptyFile()
	rootBody := f.Body()

	if m.IsRoot() {
		rootBody.AppendUnstructuredTokens(hclwrite.Tokens{
			{Type: hclsyntax.TokenComment, Bytes: []byte("# Generated by graft absorb\n")},
			{Type: hclsyntax.TokenComment, Bytes: []byte("# This manifest contains overrides to match the current remote state\n")},
		})
		rootBody.AppendNewline()
	}

	if len(m.Changes) > 0 {
		overrideBlock := rootBody.AppendNewBlock("override", nil)
		overrideBody := overrideBlock.Body()

		sort.Slice(m.Changes, func(i, j int) bool {
			if m.Changes[i].ResourceType != m.Changes[j].ResourceType {
				return m.Changes[i].ResourceType < m.Changes[j].ResourceType
			}
			return m.Changes[i].ResourceName < m.Changes[j].ResourceName
		})

		// Separate indexed and non-indexed changes
		var nonIndexed []DriftChange
		indexedGroups := make(map[string]*IndexedDriftChange) // keyed by "type.name"

		for _, change := range m.Changes {
			if change.IsIndexed() {
				resourceKey := change.resourceKey()
				if _, ok := indexedGroups[resourceKey]; !ok {
					indexedGroups[resourceKey] = &IndexedDriftChange{
						ResourceKey:  resourceKey,
						ResourceType: change.ResourceType,
						ProviderName: change.ProviderName,
						Changes:      make([]DriftChange, 0),
					}
				}
				indexedGroups[resourceKey].Changes = append(indexedGroups[resourceKey].Changes, change)
			} else {
				nonIndexed = append(nonIndexed, change)
			}
		}

		// Render non-indexed changes as before
		for _, change := range nonIndexed {
			schema := lookupResourceSchema(providerSchemas, change.ProviderName, change.ResourceType)
			block := change.ToBlock(schema)
			if block == nil {
				continue
			}
			overrideBody.AppendUnstructuredTokens(hclwrite.Tokens{
				{Type: hclsyntax.TokenComment, Bytes: []byte(fmt.Sprintf("# Absorb drift for: %s\n", change.Address))},
			})
			overrideBody.AppendBlock(block)
			overrideBody.AppendNewline()
		}

		// Render indexed groups using lookup()
		for _, key := range utils.SortedKeys(indexedGroups) {
			group := indexedGroups[key]
			schema := lookupResourceSchema(providerSchemas, group.ProviderName, group.ResourceType)
			block := group.ToBlock(schema)
			if block == nil {
				continue
			}

			// Build comment listing all addresses
			var addresses []string
			for _, change := range group.Changes {
				addresses = append(addresses, change.Address)
			}
			overrideBody.AppendUnstructuredTokens(hclwrite.Tokens{
				{Type: hclsyntax.TokenComment, Bytes: []byte(fmt.Sprintf("# Absorb drift for: %s\n", strings.Join(addresses, ", ")))},
			})
			overrideBody.AppendBlock(block)
			overrideBody.AppendNewline()
		}
	}

	if len(m.Children) > 0 {
		for _, childName := range utils.SortedKeys(m.Children) {
			child := m.Children[childName]
			modBlock := rootBody.AppendNewBlock("module", []string{child.Name})
			modBody := modBlock.Body()
			childTokens := child.ToHCL(providerSchemas)
			modBody.AppendUnstructuredTokens(childTokens)
			rootBody.AppendNewline()
		}
	}

	return f.BuildTokens(nil)
}
